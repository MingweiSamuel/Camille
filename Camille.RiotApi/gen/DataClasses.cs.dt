{{
    const spec = require(it.path + '/.spec.json');
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}

using System.Collections.Generic;
using System.Linq;
using Camille.Enums;
using Camille.RiotApi.Enums;

#if USE_NEWTONSOFT
using JsonPropertyAttribute = Newtonsoft.Json.JsonPropertyAttribute;
using JsonExtensionDataAttribute = Newtonsoft.Json.JsonExtensionDataAttribute;
#endif

#if USE_SYSTEXTJSON
using JsonPropertyAttribute = System.Text.Json.Serialization.JsonPropertyNameAttribute;
using JsonExtensionDataAttribute = System.Text.Json.Serialization.JsonExtensionDataAttribute;
#endif

// ReSharper disable RedundantStringInterpolation
// ReSharper disable InconsistentNaming

{{/* DTOs */}}
{{
    const schemas = spec.components.schemas;
    for (const schemaKey of Object.keys(schemas)) {
        if ('Error'  === schemaKey) {
            continue;
        }
        const schemaSplit = schemaKey.split('.');
        const endpoint = schemaSplit[0];
        const schemaName = dotUtils.normalizeSchemaName(schemaSplit[1]);
        const schema = schemas[schemaKey];
        const props = schema.properties;

        const fields = Object.entries(props).map(([ propKey, prop ]) => {
            const name = dotUtils.normalizePropName(propKey, schemaName, prop);
            const type = dotUtils.stringifyType(prop)
                + (schema.required && schema.required.includes(propKey) ? '' : '?');
            return { propKey, name, type, description: prop.description };
        }).sortBy(({ name }) => name);
}}
// {{= endpoint }}
namespace Camille.RiotApi.{{= dotUtils.normalizeEndpointName(endpoint) }}
{
    /// <summary>
    /// {{= schemaName }} data object. This class is automatically generated.<para />
    /// {{= schema.description || '' }}
    /// </summary>
    public class {{= schemaName }}
    {
#nullable disable
        public {{= schemaName }}() {}
#nullable restore

{{
        for (const { propKey, name, type, description } of fields)
        {
}}
{{? description }}
        /// <summary>
        /// {{= description.split('\n').map(x => x.trim()).join('<para />\r\n        /// ') }}
        /// </summary>
{{?}}
        {{= dotUtils.formatJsonProperty(propKey) }}
        public {{= type }} {{= name }} { get; set; }
{{
        }
}}

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public Dictionary<string, object> _AdditionalProperties { get; } = new Dictionary<string, object>();

        public override string ToString()
        {
            return "{{= schemaName }}"
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let propName = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
                + "{{= propName}}: " + {{= propName }} + ", "
{{
        }
}}
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

{{
    }
}}
