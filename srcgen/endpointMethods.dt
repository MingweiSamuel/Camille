{{
    const spec = require(it.path + '/.spec.json');
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using Camille.Enums;
using Camille.RiotApi.Enums;

namespace Camille.RiotApi
{
{{
    const endpointGroups = {};
    for (let path of Object.entries(spec.paths)) {
        let ep = path[1]['x-endpoint'];
        endpointGroups[ep] = endpointGroups[ep] || [];
        endpointGroups[ep].push(path);
    }
}}
{{/* Endpoint Classes */}}
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
    /// <summary>
    /// {{= endpoint }} endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#{{= endpointName }}">https://developer.riotgames.com/api-methods/#{{= endpointName }}</a>
    /// </summary>
    public class {{= endpoint }}Endpoints : Endpoints
    {
        internal {{= endpoint }}Endpoints(RiotApi riotApi) : base(riotApi)
        {}

{{
        for (let [ route, path ] of endpointMethods)
        {
            let get = path.get;
            if (!get)
                continue;
            let operationId = get.operationId;
            let method = dotUtils.capitalize(operationId.slice(operationId.indexOf('.') + 1));

            let jsonInfo = get.responses['200'].content['application/json'];
            let returnType = dotUtils.stringifyType(jsonInfo.schema, endpoint);
            if (get['x-nullable-404']) returnType += '?';

            /* Cases if not rate limited. */
            let rateLimitExcluded = get['x-app-rate-limit-excluded'] ? true : false;

            /* Description processing. */
            let desc = get.description;
            let descArr = desc
                .replace(/(#+)\s*([^\\]+)\\n(.*?)([\\n$])/g,
                    (m, g1, g2, g3, g4) => `<h${g1.length}>${g2}</h${g1.length}>\\n${g3}${g4}`)
                .split('\n');

            /* Build argument comment & string. */
            let argBuilder = [];
            let makeParamCode = '';
            let allParams = get.parameters;
            let queryParams = [];
            if (allParams && allParams.length)
            {
                let pathParams = allParams.filter(p => 'path' === p.in)
                    .sortBy(({ name }) => route.indexOf(name));
                let reqParams = allParams.filter(p => 'path' !== p.in && p.required);
                let optParams = allParams.filter(p => 'path' !== p.in && !p.required)
                    .sortBy(({ name }) => {
                        let match = /(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+)/.exec(name);
                        return match.slice(1).reverse().join('');
                    });
                queryParams = reqParams.concat(optParams);

                for (let paramList of [ pathParams, reqParams, optParams ])
                {
                    let required = paramList === pathParams;
                    for (let param of paramList)
                    {
                        argBuilder.push(', ',
                            dotUtils.stringifyType(param.schema, endpoint),
                            required ? ' ' : '? ',
                            param.name);
                        if (!required)
                            argBuilder.push(' = null');
                    }
                }
            }

            for (let asynch of [ '', 'Async' ])
            {
}}
        /// <summary>
{{
                for (var descLine of descArr)
                {
}}
        /// {{= descLine }}<para />
{{
                }
}}
        /// {{= get.externalDocs.description }}: <a href="{{= get.externalDocs.url }}">{{= get.externalDocs.url }}</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
{{
                if (allParams)
                {
                    for (let param of allParams)
                    {
}}
        /// <param name="{{= param.name }}">{{= param.description || '' }} ({{= param.required ? 'required' : 'optional' }})</param>
{{
                    }
                }
}}
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public {{= "Async" === asynch ? `Task<${returnType}>` : returnType }} {{= method }}{{= asynch }}(Region region{{= argBuilder.join('') }}, CancellationToken? cancellationToken = null)
        {
{{? queryParams.length }}
            var queryParams = new List<KeyValuePair<string, string>>();
{{
                for (let queryParam of queryParams)
                { 
}}
            {{= dotUtils.formatAddQueryParam(queryParam) }};
{{
                }
}}
{{?}}
            return RiotApi.Get{{= asynch }}<{{= returnType }}>("{{= operationId }}", $"{{= dotUtils.replaceEnumCasts(route) }}",
                region, {{= queryParams.length ? 'queryParams' : 'QUERY_PARAMS_EMPTY' }}, {{= rateLimitExcluded }}, cancellationToken);
        }

{{
            }
        }
}}
    }
{{
    }
}}
}
