{{
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}

using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Camille.Core;
using Camille.Enums;

{{= it.usings.join('\r\n') }}

#pragma warning disable IDE0017 // Simplify object initialization
#pragma warning disable IDE0028 // Simplify collection initialization

namespace Camille.{{= it.namespace }}
{
{{
    const endpointGroups = {};
    for (let routePath of Object.entries(it.spec.paths)) {
        if (!it.useMethod(routePath))
            continue;
        let ep = routePath[1]['x-endpoint'] || it.defaultEndpoint;
        if (!ep) throw Error('Failed to get endpoint for route: ' + routePath);
        (endpointGroups[ep] = endpointGroups[ep] || []).push(routePath);
    }
}}
{{/* Endpoint Classes */}}
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
    /// <summary>
    /// {{= endpoint }} endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#{{= endpointName }}">https://developer.riotgames.com/api-methods/#{{= endpointName }}</a>
    /// </summary>
    public class {{= endpoint }}Endpoints : Endpoints
    {
        internal {{= endpoint }}Endpoints(I{{= it.namespace }}Api @base) : base(@base)
        {}

{{
        for (const [ route, path ] of endpointMethods)
        {
            for (const [ verb, operation ] of Object.entries(path))
            {
                if (verb.startsWith('x-')) continue;

                const httpVerb = dotUtils.capitalize(verb);
                /* HACK for HttpMethod.Patch not existing. */
                const httpMethodShimmed = 'HttpMethod' + ('Patch' === httpVerb ? '' : '.') + httpVerb;

                const operationId = operation.operationId;
                const method = dotUtils.capitalize(operationId.slice(operationId.indexOf('.') + 1));

                const resp200 = operation.responses['200'];

                /* Return type checks. */
                let hasReturn = false;
                let returnType = 'void';
                let returnTypeBrackets = '';
                if (resp200 && resp200.content)
                {
                    hasReturn = true;
                    const jsonInfo = resp200.content['application/json'];
                    returnType = dotUtils.stringifyType(jsonInfo.schema, endpoint);
                    if (operation['x-nullable-404']) returnType += '?';
                    returnTypeBrackets = `<${returnType}>`;
                }

                /* Body content checks. */
                let bodyType = null;
                if (operation.requestBody)
                {
                    const jsonInfo = operation.requestBody.content['application/json'];
                    bodyType = dotUtils.stringifyType(jsonInfo.schema, endpoint);
                }

                /* Description processing. */
                /* Convert MD #headers to <h#> tags. */
                let descArr = operation.description
                    ? operation.description
                        .replace(/(#+)\s*([^\n]+)\n(.+?)($)/gm,
                            (m, g1, g2, g3, g4) => `<para /><h${g1.length + 2}>${g2}</h${g1.length + 2}>\n${g3}${g4}`)
                        .split('\n')
                    : [];

                /* Build argument comment & string. */
                const extraParams = it.extraParamsFn ? it.extraParamsFn(operation) : it.extraParams || [];
                const argBuilder = extraParams.flatMap(({ name, type }) => [ type, ' ', name, ', ' ]);
                const argForward = extraParams.flatMap(({ name }) => [ name, ', ' ]);

                /* Add body params after path/query. */
                if (bodyType) {
                    argBuilder.push(bodyType, ' body, ');
                    argForward.push('body, ');
                }

                const allParams = operation.parameters;
                let queryParams = [];
                let headerParams = [];
                if (allParams && allParams.length)
                {
                    const pathParams = allParams.filter(p => 'path' === p.in)
                        .sortBy(({ name }) => route.indexOf(name));

                    const reqQueryParams = allParams.filter(p => 'query' === p.in && p.required);
                    const optQueryParams = allParams.filter(p => 'query' === p.in && !p.required)
                        .sortBy(({ name }) => {
                            let match = /(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+)/.exec(name);
                            return match.slice(1).reverse().join('');
                        });
                    queryParams = reqQueryParams.concat(optQueryParams);

                    headerParams = allParams.filter(p => 'header' === p.in);

                    /* Add path, query, and header params. */
                    for (let paramList of [ pathParams, reqQueryParams, optQueryParams, headerParams ])
                    {
                        for (let param of paramList)
                        {
                            const required = param.required || paramList === pathParams;
                            argBuilder.push(
                                dotUtils.stringifyParam(param, endpoint),
                                required ? ' ' : '? ',
                                param.name,
                                required ? ', ' : ' = null, ');
                            argForward.push(param.name, ', ');
                        }
                    }
                }

                argBuilder.push('CancellationToken? cancellationToken = null');
                argForward.push('cancellationToken');

                for (const isAsync of [ false, true ])
                {
                    let methodExpr;
                    if (isAsync)
                        methodExpr = `return @base.Send${returnTypeBrackets}(${it.formatSendArgs(operation)})`;
                    else {
                        methodExpr = hasReturn ? 'return ' : '';
                        methodExpr += `${method}Async(${argForward.join('')})`;
                        methodExpr += hasReturn ? '.Result' : '.Wait()';
                    }
}}
{{? operation.externalDocs || descArr.length }}
        /// <summary>
{{? descArr.length }}
        /// {{= descArr.join('\r\n        /// ') }}
{{?}}
{{? operation.externalDocs }}
        /// {{= operation.externalDocs.description }}: <a href="{{= operation.externalDocs.url }}">{{= operation.externalDocs.url }}</a>
{{?}}
        /// </summary>
{{?}}
{{
                    extraParams.forEach(param => param.required = true);
                    for (const param of extraParams.concat(allParams || []))
                    {
                        const paramDesc = `${param.description || ''} (${param.required ? 'required' : 'optional'}${param.in ? `, in ${param.in}` : ''})`.trim();
}}
        /// <param name="{{= param.name }}">{{= paramDesc }}</param>
{{
                    }
}}
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task. (optional)</param>
{{? !isAsync }}
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
{{?}}
        public {{= isAsync ? `Task${returnTypeBrackets}` : returnType }} {{= method }}{{= isAsync ? 'Async' : '' }}({{= argBuilder.join('') }})
        {
{{? isAsync }}
{{? queryParams.length }}
            var queryParams = new List<KeyValuePair<string?, string?>>();
{{
                    for (const queryParam of queryParams)
                    { 
}}
            {{= dotUtils.formatAddQueryParam(queryParam) }};
{{
                    }
}}
            HttpRequestMessage request;
            using (var content = new FormUrlEncodedContent(queryParams))
                request = new HttpRequestMessage({{= httpMethodShimmed }}, $"{{= dotUtils.replaceEnumCasts(route) }}?{content.ReadAsStringAsync().Result}");
{{?}}
{{? !queryParams.length }}
            var request = new HttpRequestMessage({{= httpMethodShimmed }}, $"{{= dotUtils.replaceEnumCasts(route) }}");
{{?}}
{{
                    for (const headerParam of headerParams)
                    {
}}
            request.Headers.Add(nameof({{= headerParam.name }}), {{= headerParam.name }});
{{
                    }
}}
{{? bodyType }}
            request.Content = new StringContent(JsonHandler.Serialize(body), Encoding.UTF8, "application/json");
{{?}}
{{?}}
            {{= methodExpr }};
        }

{{
                }
            }
        }
}}
    }
{{
    }
}}
}

#pragma warning restore IDE0028 // Simplify collection initialization
#pragma warning restore IDE0017 // Simplify object initialization
