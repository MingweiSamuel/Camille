{{
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}


{{= it.header }}

using System.Collections.Generic;
using System.Linq;

{{= it.usings.join('\r\n') }}

#if USE_NEWTONSOFT
using JsonPropertyAttribute = Newtonsoft.Json.JsonPropertyAttribute;
using JsonExtensionDataAttribute = Newtonsoft.Json.JsonExtensionDataAttribute;
#elif USE_SYSTEXTJSON
using JsonPropertyAttribute = System.Text.Json.Serialization.JsonPropertyNameAttribute;
using JsonExtensionDataAttribute = System.Text.Json.Serialization.JsonExtensionDataAttribute;
#else
#error One of USE_NEWTONSOFT or USE_SYSTEXTJSON must be set.
#endif

// ReSharper disable InconsistentNaming

{{/* DTOs */}}
{{
    const schemas = it.spec.components.schemas;
    for (const schemaEntry of Object.entries(schemas)) {
        const [ schemaKey, schema ] = schemaEntry;
        if (!it.useSchema(schemaKey)) {
            continue;
        }
        const scheamKeySegs = schemaKey.split('.');
        const schemaName = dotUtils.normalizeSchemaName(scheamKeySegs.pop());
        const props = schema.properties;
        const enums = !props && schema.enum;
        const endpointRawName = scheamKeySegs.join('.') || it.defaultEndpoint;
        if (!endpointRawName) throw Error('Failed to get endpoint name');
}}
namespace Camille.{{= it.namespace }}.{{= dotUtils.normalizeEndpointName(endpointRawName) }}
{
    /// <summary>
    /// {{= schemaName }} data object. This class is automatically generated.<para />
    /// {{= dotUtils.formatComment(schema.description || '', 4) }}
    /// </summary>
{{? enums }}
{{? 'string' === schema.type }}
#if USE_SYSTEXTJSON
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
#endif
{{?}}
    public enum {{= schemaName }}
    {
        {{= enums.map(dotUtils.escapeKeyword).join(',\r\n        ') }}
{{?}}
{{? !enums }}
    public class {{= schemaName }}
    {
{{
        const fields = Object.entries(props).map(([ propKey, prop ]) => {
            const name = dotUtils.normalizePropName(propKey, schemaName, prop);
            const type = dotUtils.stringifyType(prop)
                + (schema.required && schema.required.includes(propKey) ? '' : '?');
            return { propKey, name, type, description: prop.description };
        }).sortBy(({ name }) => name);
}}

#nullable disable
        public {{= schemaName }}() {}
#nullable restore

{{
        for (const { propKey, name, type, description } of fields)
        {
}}
{{? description }}
        /// <summary>
        /// {{= dotUtils.formatComment(description, 8) }}
        /// </summary>
{{?}}
        {{= dotUtils.formatJsonProperty(propKey) }}
        public {{= type }} {{= name }} { get; set; }
{{
        }
}}

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE1006:Naming Styles")]
        public Dictionary<string, object> _AdditionalProperties { get; set; } = new Dictionary<string, object>();

        public override string ToString()
        {
            return "{{= schemaName }}("
{{
        for (const [ propKey, prop ] of Object.entries(props))
        {
            const propName = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
                + "{{= propName}}: " + {{= propName }} + ", "
{{
        }
}}
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
{{?}}
    }
}

{{
    }
}}
