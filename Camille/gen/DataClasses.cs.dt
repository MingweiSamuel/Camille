{{
    const spec = require('./.spec.json');
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}

using System.Collections.Generic;
using System.Linq;
using MingweiSamuel.Camille.Enums;

#if USE_NEWTONSOFT
using JsonPropertyAttribute = Newtonsoft.Json.JsonPropertyAttribute;
using JsonExtensionDataAttribute = Newtonsoft.Json.JsonExtensionDataAttribute;
#endif

#if USE_SYSTEXTJSON
using JsonPropertyAttribute = System.Text.Json.Serialization.JsonPropertyNameAttribute;
using JsonExtensionDataAttribute = System.Text.Json.Serialization.JsonExtensionDataAttribute;
#endif

// ReSharper disable RedundantStringInterpolation
// ReSharper disable InconsistentNaming

{{/* DTOs */}}
{{
    let schemas = spec.components.schemas;
    for (let schemaKey of Object.keys(schemas)) {
        if ('Error'  === schemaKey) {
            continue;
        }
        let schemaSplit = schemaKey.split('.');
        let endpoint = schemaSplit[0];
        if ('lol-static-data-v3' === endpoint) { continue; }
        let schemaName = dotUtils.normalizeSchemaName(schemaSplit[1]);
        let schema = schemas[schemaKey];
        let props = schema.properties;
}}
// {{= endpoint }}
namespace MingweiSamuel.Camille.{{= dotUtils.normalizeEndpointName(endpoint) }}
{
#nullable disable
    /// <summary>
    /// {{= schemaName }} data object. This class is automatically generated.<para />
    /// {{= schema.description || '' }}
    /// </summary>
    public class {{= schemaName }}
    {
        public {{= schemaName }}()
        {}
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let name = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
{{? prop.description }}
        /// <summary>
        /// {{= prop.description.split('\n').map(x => x.trim()).join('<para />\r\n        /// ') }}
        /// </summary>
{{?}}
        {{= dotUtils.formatJsonProperty(propKey) }}
        public {{= dotUtils.stringifyType(prop) }} {{= name }} { get; set; }
{{
        }
}}

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public Dictionary<string, object> _AdditionalProperties { get; } = new Dictionary<string, object>();

        public override string ToString()
        {
            return "{{= schemaName }}"
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let propName = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
                + "{{= propName}}: " + {{= propName }} + ", "
{{
        }
}}
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
#nullable restore
}

{{
    }
}}
