{{
    const spec = require('./.spec.json');
    const dotUtils = require('./dotUtils.js');
}}
// This file is automatically generated.
// Do not directly edit.
// Generated on {{= (new Date).toISOString() }}

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using MingweiSamuel.Camille.Enums;

// ReSharper disable RedundantStringInterpolation
// ReSharper disable InconsistentNaming

#region methods
namespace MingweiSamuel.Camille
{
{{
    const endpointGroups = {};
    for (let path of Object.entries(spec.paths)) {
        let ep = path[1]['x-endpoint'];
        endpointGroups[ep] = endpointGroups[ep] || [];
        endpointGroups[ep].push(path);
    }
}}
{{/* RiotApi Class */}}
    public partial class RiotApi
    {
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
        public readonly {{= endpoint }}Endpoints {{= endpoint }};
{{
    }
}}

        private RiotApi()
        {
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
            {{= endpoint }} = new {{= endpoint }}Endpoints(this);
{{
    }
}}
        }
    }

{{/* Endpoint Classes */}}
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
    /// <summary>
    /// {{= endpoint }} endpoints. This class is automatically generated.<para />
    /// Official API Reference <a href="https://developer.riotgames.com/api-methods/#{{= endpointName }}">https://developer.riotgames.com/api-methods/#{{= endpointName }}</a>
    /// </summary>
    public class {{= endpoint }}Endpoints : Endpoints
    {
        internal {{= endpoint }}Endpoints(RiotApi riotApi) : base(riotApi)
        {}

{{
        for (let [ route, path ] of endpointMethods)
        {
            let get = path.get;
            if (!get)
                continue;
            let operationId = get.operationId;
            let method = dotUtils.capitalize(operationId.slice(operationId.indexOf('.') + 1));

            let jsonInfo = get.responses['200'].content['application/json'];
            let returnType = dotUtils.stringifyType(jsonInfo.schema, endpoint);

            /* Cases if not rate limited. */
            let rateLimitExcluded = get['x-app-rate-limit-excluded'] ? true : false;

            /* Description processing. */
            let desc = get.description;
            let descArr = desc
                .replace(/(#+)\s*([^\\]+)\\n(.*?)([\\n$])/g,
                    (m, g1, g2, g3, g4) => `<h${g1.length}>${g2}</h${g1.length}>\\n${g3}${g4}`)
                .split('\n');

            /* Build argument comment & string. */
            let argBuilder = [];
            let makeParamCode = '';
            let allParams = get.parameters;
            if (allParams && allParams.length)
            {
                let pathParams = allParams.filter(p => 'path' === p.in)
                    .sort(p => route.indexOf(p.name));
                let reqParams = allParams.filter(p => 'path' !== p.in && p.required);
                let optParams = allParams.filter(p => 'path' !== p.in && !p.required)
                    .sort(p => {
                        let match = /(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+)/.exec(p.name);
                        return match.slice(1).reverse().join('');
                    });
                for (let paramList of [ pathParams, reqParams, optParams ])
                {
                    let required = paramList === pathParams;
                    for (let param of paramList)
                    {
                        argBuilder.push(', ',
                            dotUtils.stringifyType(param.schema, endpoint, !required),
                            ' ', param.name);
                        if (!required)
                            argBuilder.push(' = null');
                    }
                }
                makeParamCode = reqParams.concat(optParams)
                    .map(p => p.name)
                    .flatMap(n => [ `nameof(${n})`, n ])
                    .join(', ');
            }

            for (let asynch of [ '', 'Async' ])
            {
}}
        /// <summary>
{{
                for (var descLine of descArr)
                {
}}
        /// {{= descLine }}<para />
{{
                }
}}
        /// {{= get.externalDocs.description }}: <a href="{{= get.externalDocs.url }}">{{= get.externalDocs.url }}</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
{{
                if (allParams)
                {
                    for (let param of allParams)
                    {
}}
        /// <param name="{{= param.name }}">{{= param.description || '' }} ({{= param.required ? 'required' : 'optional' }})</param>
{{
                    }
                }
}}
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public {{= "Async" === asynch ? `Task<${returnType}>` : returnType }} {{= method }}{{= asynch }}(Region region{{= argBuilder.join('') }}, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get{{= asynch }}<{{= returnType }}>("{{= operationId }}", $"{{= route }}",
                region, MakeParams({{= makeParamCode }}), {{= rateLimitExcluded }}, cancellationToken);
        }

{{
            }
        }
}}
    }
{{
    }
}}
}
#endregion

#region data objects
{{/* DTOs */}}
{{
    let schemas = spec.components.schemas;
    for (let schemaKey of Object.keys(schemas)) {
        if ('Error'  === schemaKey) {
            continue;
        }
        let schemaSplit = schemaKey.split('.');
        let endpoint = schemaSplit[0];
        if ('lol-static-data-v3' === endpoint) { continue; }
        let schemaName = dotUtils.normalizeSchemaName(schemaSplit[1]);
        let schema = schemas[schemaKey];
        let props = schema.properties;
}}
// {{= endpoint }}
namespace MingweiSamuel.Camille.{{= dotUtils.normalizeEndpointName(endpoint) }}
{
    /// <summary>
    /// {{= schemaName }} data object. This class is automatically generated.<para />
    /// {{= schema.description || '' }}
    /// </summary>
    public class {{= schemaName }}
    {
        public {{= schemaName }}({{= Object.entries(props)
            .map(([ key, value ]) => dotUtils.formatJsonProperty(key) + ' ' +
                dotUtils.stringifyType(value) + ' ' + dotUtils.normalizeArgName(key))
            .join(',\r\n                ') }})
        {
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let name = dotUtils.normalizePropName(propKey, schemaName, prop);
            if (name === schemaName)
                name += dotUtils.stringifyType(prop);
            let argName = dotUtils.normalizeArgName(propKey);
            let thiz = argName === name ? 'this.' : '';
}}
            {{= thiz }}{{= name }} = {{= argName }};
{{
        }
}}
        }
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let name = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
{{? prop.description }}
        /// <summary>
        /// {{= prop.description.split('\n').map(x => x.trim()).join('<para />\r\n        /// ') }}
        /// </summary>
{{?}}
        {{= dotUtils.formatJsonProperty(propKey) }}
        public {{= dotUtils.stringifyType(prop) }} {{= name }} { get; }
{{
        }
}}

        /// <summary>Contains any extra JSON properties that did not map to fields.</summary>
        [JsonExtensionData]
        public Dictionary<string, object> _AdditionalProperties { get; } = new Dictionary<string, object>();

        public override string ToString()
        {
            return "{{= schemaName }}"
{{
        for (let [ propKey, prop ] of Object.entries(props))
        {
            let propName = dotUtils.normalizePropName(propKey, schemaName, prop);
}}
                + "{{= propName}}: " + {{= propName }} + ", "
{{
        }
}}
                + "_AdditionalProperties: {" + string.Join(", ", _AdditionalProperties.Select(kv => $"\"{kv.Key}\": {kv.Value}")) + "})";
        }
    }
}

{{
    }
}}
#endregion
